"""
Asterisk Manager Interface (AMI) Client
Handles connection and communication with Asterisk
"""

import asyncio
import logging
import os
from typing import Optional, Dict, Any
from panoramisk import Manager

logger = logging.getLogger(__name__)

class AsteriskAMIClient:
    def __init__(self):
        self.host = os.getenv("ASTERISK_HOST", "asterisk")
        self.port = int(os.getenv("ASTERISK_PORT", 5038))
        self.username = os.getenv("ASTERISK_USER", "admin")
        self.password = os.getenv("ASTERISK_PASSWORD", "admin_secret")
        
        self.manager: Optional[Manager] = None
        self.connected = False
        self.broadcast_callback = None
        
        # Track active calls
        self.active_calls = {}
        
        logger.info(f"AMI Client initialized for {self.host}:{self.port}")

    def set_broadcast_callback(self, callback):
        """Set callback function for broadcasting events"""
        self.broadcast_callback = callback

    async def connect(self):
        """Connect to Asterisk AMI"""
        try:
            logger.info(f"Connecting to Asterisk AMI at {self.host}:{self.port}...")
            
            self.manager = Manager(
                host=self.host,
                port=self.port,
                username=self.username,
                secret=self.password,
                ping_delay=10,
                ping_attempts=3
            )
            
            await self.manager.connect()
            self.connected = True
            
            logger.info("✓ Successfully connected to Asterisk AMI")
            
            # Register event handlers
            self.manager.register_event('*', self.handle_event)
            
            # Keep connection alive
            while self.connected:
                await asyncio.sleep(1)
                
        except Exception as e:
            logger.error(f"✗ Failed to connect to Asterisk AMI: {e}")
            self.connected = False
            
            # Retry connection after 5 seconds
            await asyncio.sleep(5)
            await self.connect()

    async def disconnect(self):
        """Disconnect from Asterisk AMI"""
        if self.manager:
            await self.manager.close()
            self.connected = False
            logger.info("Disconnected from Asterisk AMI")

    async def handle_event(self, manager, event):
        """Handle all Asterisk events"""
        event_name = event.get('Event', 'Unknown')
        
        # Track call events
        if event_name == 'Newchannel':
            await self.handle_new_channel(event)
        elif event_name == 'Hangup':
            await self.handle_hangup(event)
        elif event_name == 'DialBegin':
            await self.handle_dial_begin(event)
        elif event_name == 'DialEnd':
            await self.handle_dial_end(event)
        
        # Log important events
        if event_name in ['PeerStatus', 'Registry', 'Newchannel', 'Hangup', 'NewCallerid', 'DialBegin', 'DialEnd']:
            logger.info(f"AMI Event: {event_name} - {event}")
            
            # Broadcast to WebSocket clients
            if self.broadcast_callback:
                await self.broadcast_callback({
                    'type': 'ami_event',
                    'event_name': event_name,
                    'event': dict(event),
                    'active_calls': list(self.active_calls.values())
                })

    async def handle_new_channel(self, event):
        """Handle new channel creation"""
        channel = event.get('Channel', '')
        caller_num = event.get('CallerIDNum', '')
        
        if channel and 'PJSIP' in channel:
            self.active_calls[channel] = {
                'channel': channel,
                'caller': caller_num,
                'destination': '',
                'state': 'ringing',
                'start_time': event.get('Timestamp', '')
            }

    async def handle_dial_begin(self, event):
        """Handle dial begin"""
        dest_channel = event.get('DestChannel', '')
        dest_num = event.get('DestCallerIDNum', '')
        
        if dest_channel:
            # Update the call with destination
            for call_id, call in self.active_calls.items():
                if call['destination'] == '':
                    call['destination'] = dest_num
                    call['state'] = 'ringing'
                    break

    async def handle_dial_end(self, event):
        """Handle dial end"""
        channel = event.get('Channel', '')
        if channel in self.active_calls:
            self.active_calls[channel]['state'] = 'connected'

    async def handle_hangup(self, event):
        """Handle call hangup"""
        channel = event.get('Channel', '')
        
        if channel in self.active_calls:
            del self.active_calls[channel]
            
            # Broadcast updated call list
            if self.broadcast_callback:
                await self.broadcast_callback({
                    'type': 'call_ended',
                    'channel': channel,
                    'active_calls': list(self.active_calls.values())
                })

    async def send_action(self, action: str, **kwargs) -> Dict[str, Any]:
        """Send an action to Asterisk and wait for response"""
        if not self.connected or not self.manager:
            raise Exception("Not connected to Asterisk")
        
        try:
            response = await self.manager.send_action({
                'Action': action,
                **kwargs
            })
            return response
        except Exception as e:
            logger.error(f"Error sending action {action}: {e}")
            raise

    async def get_active_channels(self):
        """Get currently active channels"""
        return list(self.active_calls.values())
