"""
PJSIP Configuration Generator
"""
import os
import logging
import subprocess
from typing import List
from database import SIPPeer, SIPTrunk
from version import VERSION

logger = logging.getLogger(__name__)

PJSIP_CONFIG_PATH = "/etc/asterisk/custom/pjsip.conf"
EXTERNAL_IP = os.getenv("EXTERNAL_IP", "127.0.0.1")

DEFAULT_CODECS = "ulaw,alaw,g722,opus"


def generate_pjsip_config(peers: List[SIPPeer], global_codecs: str = DEFAULT_CODECS) -> str:
    """Generate complete pjsip.conf content"""

    # Build allow lines from global codecs
    codec_list = [c.strip() for c in global_codecs.split(",") if c.strip()]
    allow_lines = "\n".join(f"allow={c}" for c in codec_list)

    config = f"""; Auto-generated PJSIP configuration
; Generated by Asterisk PBX GUI

[global]
type=global
max_forwards=70
user_agent=GonoPBX {VERSION}

[transport-udp]
type=transport
protocol=udp
bind=0.0.0.0:5060
external_media_address={EXTERNAL_IP}
external_signaling_address={EXTERNAL_IP}
local_net=172.0.0.0/8
local_net=10.0.0.0/8

[transport-tcp]
type=transport
protocol=tcp
bind=0.0.0.0:5060

[endpoint-basic](!)
type=endpoint
context=internal
disallow=all
{allow_lines}
direct_media=no
rtp_symmetric=yes
force_rport=yes
rewrite_contact=yes
ice_support=yes

[auth-basic](!)
type=auth
auth_type=userpass

[aor-basic](!)
type=aor
max_contacts=5
remove_existing=yes
qualify_frequency=60

; === Peers ===
"""

    for peer in peers:
        if peer.enabled:
            # Per-peer codec override
            peer_codec_lines = ""
            if peer.codecs:
                peer_codecs = [c.strip() for c in peer.codecs.split(",") if c.strip()]
                peer_codec_lines = "\ndisallow=all\n" + "\n".join(f"allow={c}" for c in peer_codecs)

            config += f"""
[{peer.extension}](endpoint-basic)
auth=auth{peer.extension}
aors={peer.extension}
callerid="{peer.caller_id or peer.extension}" <{peer.extension}>{peer_codec_lines}

[auth{peer.extension}](auth-basic)
username={peer.extension}
password={peer.secret}

[{peer.extension}](aor-basic)
"""

    return config


def generate_trunk_config(trunk: SIPTrunk) -> str:
    """Generate PJSIP config section for a single SIP trunk"""
    tid = trunk.id
    config = f"\n; --- Trunk: {trunk.name} (ID {tid}) ---\n"

    if trunk.auth_mode == "registration":
        config += f"""
[trunk-{tid}]
type=registration
outbound_auth=trunk-auth-{tid}
server_uri=sip:{trunk.sip_server}
client_uri=sip:{trunk.username}@{trunk.sip_server}
contact_user={trunk.username}

[trunk-ep-{tid}]
type=endpoint
outbound_auth=trunk-auth-{tid}
aors=trunk-aor-{tid}
context={trunk.context}
from_domain={trunk.sip_server}
disallow=all
allow={trunk.codecs}
direct_media=no
rtp_symmetric=yes
force_rport=yes
rewrite_contact=yes

[trunk-auth-{tid}]
type=auth
auth_type=userpass
username={trunk.username}
password={trunk.password}

[trunk-aor-{tid}]
type=aor
contact=sip:{trunk.sip_server}
qualify_frequency=60

[trunk-identify-{tid}]
type=identify
endpoint=trunk-ep-{tid}
match={trunk.sip_server}
"""
    else:
        # IP-based auth (no registration, no auth block)
        config += f"""
[trunk-ep-{tid}]
type=endpoint
aors=trunk-aor-{tid}
context={trunk.context}
from_domain={trunk.sip_server}
disallow=all
allow={trunk.codecs}
direct_media=no
rtp_symmetric=yes
force_rport=yes
rewrite_contact=yes

[trunk-aor-{tid}]
type=aor
contact=sip:{trunk.sip_server}
qualify_frequency=60

[trunk-identify-{tid}]
type=identify
endpoint=trunk-ep-{tid}
match={trunk.sip_server}
"""

    return config


def write_pjsip_config(peers: List[SIPPeer], trunks: List[SIPTrunk] = None, global_codecs: str = DEFAULT_CODECS) -> bool:
    """Write PJSIP config to file"""
    try:
        config_content = generate_pjsip_config(peers, global_codecs)

        if trunks:
            config_content += "\n; === SIP Trunks ===\n"
            for trunk in trunks:
                if trunk.enabled:
                    config_content += generate_trunk_config(trunk)

        os.makedirs(os.path.dirname(PJSIP_CONFIG_PATH), exist_ok=True)

        with open(PJSIP_CONFIG_PATH, 'w') as f:
            f.write(config_content)

        logger.info(f"PJSIP config written with {len(peers)} peers, {len(trunks or [])} trunks")
        return True

    except Exception as e:
        logger.error(f"Failed to write PJSIP config: {e}")
        return False

def reload_asterisk() -> bool:
    """Reload Asterisk PJSIP - copy config inside Asterisk container"""
    try:
        # Kopiere die Config IM Asterisk-Container (nicht vom Backend aus)
        result = subprocess.run(
            ['docker', 'exec', 'pbx_asterisk', 'sh', '-c',
             'cp /etc/asterisk/custom/pjsip.conf /etc/asterisk/pjsip.conf && asterisk -rx "pjsip reload"'],
            capture_output=True,
            text=True,
            timeout=10
        )

        if result.returncode == 0:
            logger.info(f"Asterisk reloaded successfully")
            return True
        else:
            logger.error(f"Reload failed: {result.stderr}")
            return False

    except Exception as e:
        logger.error(f"Failed to reload: {e}")
        return False
